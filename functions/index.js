const functions = require('firebase-functions');
const admin = require('firebase-admin');
const { GoogleGenAI } = require('@google/genai');

admin.initializeApp();

// Initialize Gemini AI with API key from environment
const getGeminiClient = () => {
    const apiKey = process.env.GEMINI_API_KEY;
    if (!apiKey) {
        throw new Error('GEMINI_API_KEY not configured');
    }
    return new GoogleGenAI({ apiKey });
};

/**
 * Cloud Function: createUserDocument
 * Triggered when a new user signs up via Firebase Auth
 * Creates a user document in Firestore with 1 free credit
 */
exports.createUserDocument = functions.auth.user().onCreate(async (user) => {
    const { uid, email, displayName, photoURL } = user;

    try {
        await admin.firestore().collection('users').doc(uid).set({
            email: email || null,
            displayName: displayName || null,
            photoURL: photoURL || null,
            credits: 1, // 1 free credit for new users
            createdAt: admin.firestore.FieldValue.serverTimestamp(),
            lastUsedAt: admin.firestore.FieldValue.serverTimestamp(),
        });

        console.log(`Created user document for ${uid}`);
    } catch (error) {
        console.error('Error creating user document:', error);
    }
});

/**
 * Cloud Function: generateImage
 * Securely proxies Gemini API calls for image generation
 * Verifies user has credits and deducts 1 credit on success
 */
exports.generateImage = functions
    .runWith({
        secrets: ['GEMINI_API_KEY'],
        timeoutSeconds: 540,
        memory: '1GB'
    })
    .https.onCall(async (data, context) => {
        // 1. Verify authentication
        if (!context.auth) {
            throw new functions.https.HttpsError(
                'unauthenticated',
                'You must be signed in to generate images.'
            );
        }

        const userId = context.auth.uid;
        const { base64Image, filters } = data;

        // 2. Validate input
        if (!base64Image || !filters || !Array.isArray(filters)) {
            throw new functions.https.HttpsError(
                'invalid-argument',
                'Missing required fields: base64Image and filters'
            );
        }

        try {
            // 3. Check user credits
            const userRef = admin.firestore().collection('users').doc(userId);
            const userDoc = await userRef.get();

            if (!userDoc.exists) {
                throw new functions.https.HttpsError(
                    'not-found',
                    'User document not found'
                );
            }

            const userData = userDoc.data();
            if (userData.credits <= 0) {
                throw new functions.https.HttpsError(
                    'resource-exhausted',
                    'Insufficient credits. Please purchase more credits.'
                );
            }

            // 4. Call Gemini API
            const ai = getGeminiClient();

            // Build prompt from filters
            const changesList = filters.map(f => `- ${f.promptFragment}`).join('\n');
            const prompt = `
      You are an expert image editor specialized in urban renewal and civic planning visualization.
      
      Edit the attached image to show how it would look if it were perfectly maintained, clean, and upgraded. 
      Strictly maintain the original perspective, lighting direction, and main building structures. 
      Do not change the time of day. 
      
      CRITICAL: Treat any weathered, stained, peeling, or moldy wall surfaces as defects that must be repaired and painted.
      
      Apply the following specific modifications:
      ${changesList}
      
      Ensure the result looks photorealistic, natural, and inviting.
    `;

            const response = await ai.models.generateContent({
                model: 'gemini-3-pro-image-preview',
                contents: [
                    {
                        inlineData: {
                            mimeType: 'image/jpeg',
                            data: base64Image,
                        },
                    },
                    {
                        text: prompt,
                    },
                ],
            });

            // 5. Extract generated image
            const parts = response.candidates?.[0]?.content?.parts;
            if (!parts) {
                throw new functions.https.HttpsError(
                    'internal',
                    'No content generated by Gemini API'
                );
            }

            let generatedBase64 = '';
            for (const part of parts) {
                if (part.inlineData && part.inlineData.data) {
                    generatedBase64 = part.inlineData.data;
                    break;
                }
            }

            if (!generatedBase64) {
                throw new functions.https.HttpsError(
                    'internal',
                    'No image data found in Gemini response'
                );
            }

            // 6. Deduct 1 credit (using transaction for atomicity)
            await admin.firestore().runTransaction(async (transaction) => {
                const freshUserDoc = await transaction.get(userRef);
                const freshCredits = freshUserDoc.data().credits;

                if (freshCredits <= 0) {
                    throw new functions.https.HttpsError(
                        'resource-exhausted',
                        'Insufficient credits'
                    );
                }

                transaction.update(userRef, {
                    credits: admin.firestore.FieldValue.increment(-1),
                    lastUsedAt: admin.firestore.FieldValue.serverTimestamp(),
                });
            });

            // 7. Return generated image and updated credit count
            const updatedUserDoc = await userRef.get();
            const updatedCredits = updatedUserDoc.data().credits;

            return {
                success: true,
                generatedImage: generatedBase64,
                credits: updatedCredits,
            };

        } catch (error) {
            console.error('Error in generateImage:', error);

            if (error.code && error.code.startsWith('functions/')) {
                throw error; // Re-throw HttpsErrors
            }

            throw new functions.https.HttpsError(
                'internal',
                'Failed to generate image: ' + error.message
            );
        }
    });

/**
 * Cloud Function: addCredits
 * Called after successful payment to add credits to user account
 * In production, this would be called by a payment webhook (Razorpay/Stripe)
 */
exports.addCredits = functions.https.onCall(async (data, context) => {
    // Verify authentication
    if (!context.auth) {
        throw new functions.https.HttpsError(
            'unauthenticated',
            'You must be signed in'
        );
    }

    const userId = context.auth.uid;
    const { amount, paymentId } = data;

    // In production, verify payment with Razorpay/Stripe here
    // For now, this is a placeholder

    if (!amount || amount <= 0) {
        throw new functions.https.HttpsError(
            'invalid-argument',
            'Invalid credit amount'
        );
    }

    try {
        const userRef = admin.firestore().collection('users').doc(userId);

        await userRef.update({
            credits: admin.firestore.FieldValue.increment(amount),
            lastPurchaseAt: admin.firestore.FieldValue.serverTimestamp(),
        });

        const updatedDoc = await userRef.get();
        const updatedCredits = updatedDoc.data().credits;

        console.log(`Added ${amount} credits to user ${userId}`);

        return {
            success: true,
            credits: updatedCredits,
            message: `Successfully added ${amount} credits`,
        };
    } catch (error) {
        throw new functions.https.HttpsError(
            'internal',
            'Failed to add credits: ' + error.message
        );
    }
});

/**
 * Cloud Function: createRazorpayOrder
 * Creates a Razorpay order for credit purchase
 */
exports.createRazorpayOrder = functions
    .runWith({
        secrets: ['RAZORPAY_KEY_SECRET']
    })
    .https.onCall(async (data, context) => {
        // Verify authentication
        if (!context.auth) {
            throw new functions.https.HttpsError(
                'unauthenticated',
                'You must be signed in to purchase credits'
            );
        }

        const userId = context.auth.uid;
        const { packageId, amount, credits } = data;

        // Validate input
        if (!packageId || !amount || !credits) {
            throw new functions.https.HttpsError(
                'invalid-argument',
                'Missing required fields: packageId, amount, credits'
            );
        }

        try {
            const { initializeRazorpay } = require('./razorpay-utils');

            // Initialize Razorpay (Note: In production, use live keys)
            const razorpay = initializeRazorpay(
                'rzp_test_Rwc2KsHXZMjLuQ',  // Key ID (can be public)
                process.env.RAZORPAY_KEY_SECRET  // Secret key (from Firebase secret)
            );

            // Create order
            const order = await razorpay.orders.create({
                amount: amount * 100, // Convert to paise (â‚¹49 = 4900 paise)
                currency: 'INR',
                receipt: `order_${userId}_${Date.now()}`,
                notes: {
                    userId,
                    packageId,
                    credits,
                }
            });

            console.log(`Created Razorpay order: ${order.id} for user ${userId}`);

            return {
                success: true,
                orderId: order.id,
                amount: order.amount,
                currency: order.currency,
                keyId: 'rzp_test_Rwc2KsHXZMjLuQ'  // Needed for client-side checkout
            };

        } catch (error) {
            console.error('Error creating Razorpay order:', error);
            throw new functions.https.HttpsError(
                'internal',
                'Failed to create payment order: ' + error.message
            );
        }
    });

/**
 * Cloud Function: razorpayWebhook
 * Receives webhook notifications from Razorpay
 * Verifies signature and adds credits on successful payment
 */
exports.razorpayWebhook = functions
    .runWith({
        secrets: ['RAZORPAY_WEBHOOK_SECRET']
    })
    .https.onRequest(async (req, res) => {
        try {
            const { verifyWebhookSignature } = require('./razorpay-utils');

            const signature = req.headers['x-razorpay-signature'];
            const payload = req.body;

            // Verify webhook signature
            const isValid = verifyWebhookSignature(
                payload,
                signature,
                process.env.RAZORPAY_WEBHOOK_SECRET
            );

            if (!isValid) {
                console.error('Invalid webhook signature');
                return res.status(400).send('Invalid signature');
            }

            const event = payload.event;
            console.log(`Received Razorpay webhook: ${event}`);

            // Handle payment.captured event
            if (event === 'payment.captured') {
                const paymentEntity = payload.payload.payment.entity;
                const orderId = paymentEntity.order_id;
                const paymentId = paymentEntity.id;
                const amount = paymentEntity.amount; // in paise

                // Get order notes to find userId and credits
                const { initializeRazorpay } = require('./razorpay-utils');
                const razorpay = initializeRazorpay(
                    'rzp_test_Rwc2KsHXZMjLuQ',
                    process.env.RAZORPAY_KEY_SECRET
                );

                const order = await razorpay.orders.fetch(orderId);
                const { userId, credits } = order.notes;

                if (!userId || !credits) {
                    console.error('Missing userId or credits in order notes');
                    return res.status(400).send('Invalid order data');
                }

                // Add credits to user using transaction
                const userRef = admin.firestore().collection('users').doc(userId);

                // Check if payment already processed (prevent double credit)
                const paymentsRef = admin.firestore().collection('payments');
                const existingPayment = await paymentsRef.doc(paymentId).get();

                if (existingPayment.exists) {
                    console.log(`Payment ${paymentId} already processed`);
                    return res.status(200).send('OK');
                }

                // Add credits and record payment
                await admin.firestore().runTransaction(async (transaction) => {
                    const userDoc = await transaction.get(userRef);

                    if (!userDoc.exists) {
                        throw new Error('User not found');
                    }

                    // Update user credits
                    transaction.update(userRef, {
                        credits: admin.firestore.FieldValue.increment(parseInt(credits)),
                        lastPurchaseAt: admin.firestore.FieldValue.serverTimestamp(),
                    });

                    // Record payment
                    transaction.set(paymentsRef.doc(paymentId), {
                        userId,
                        orderId,
                        paymentId,
                        amount: amount / 100, // Convert to rupees
                        credits: parseInt(credits),
                        status: 'captured',
                        createdAt: admin.firestore.FieldValue.serverTimestamp(),
                    });
                });

                console.log(`Added ${credits} credits to user ${userId} for payment ${paymentId}`);
            }

            res.status(200).send('OK');

        } catch (error) {
            console.error('Error processing webhook:', error);
            res.status(500).send('Internal error');
        }
    });
