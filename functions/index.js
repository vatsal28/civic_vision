const functions = require('firebase-functions');
const admin = require('firebase-admin');
const crypto = require('crypto');
const { GoogleGenAI } = require('@google/genai');

admin.initializeApp();

/**
 * Credit Packages - SINGLE SOURCE OF TRUTH
 * All pricing decisions based on this, never client data
 * SECURITY: Never trust client-sent amount or credits
 */
const PACKAGES = {
    'starter': { id: 'starter', credits: 10, price: 49, name: 'Starter Pack' },
    'popular': { id: 'popular', credits: 50, price: 199, name: 'Popular Pack' },
    'pro': { id: 'pro', credits: 100, price: 349, name: 'Pro Pack' }
};

// Initialize Gemini AI with API key from environment
const getGeminiClient = () => {
    const apiKey = process.env.GEMINI_API_KEY;
    if (!apiKey) {
        throw new Error('GEMINI_API_KEY not configured');
    }
    return new GoogleGenAI({ apiKey });
};

/**
 * Cloud Function: createUserDocument
 * Triggered when a new user signs up via Firebase Auth
 * Creates a user document in Firestore with 3 free credits
 */
exports.createUserDocument = functions.auth.user().onCreate(async (user) => {
    const { uid, email, displayName, photoURL } = user;

    try {
        await admin.firestore().collection('users').doc(uid).set({
            email: email || null,
            displayName: displayName || null,
            photoURL: photoURL || null,
            credits: 3, // 3 free credits for new users
            createdAt: admin.firestore.FieldValue.serverTimestamp(),
            lastUsedAt: admin.firestore.FieldValue.serverTimestamp(),
        });

        console.log(`Created user document for ${uid} with 3 free credits`);
    } catch (error) {
        console.error('Error creating user document:', error);
    }
});

/**
 * Cloud Function: generateImage
 * Securely proxies Gemini API calls for image generation
 * Verifies user has credits and deducts 1 credit on success
 */
exports.generateImage = functions
    .runWith({
        secrets: ['GEMINI_API_KEY'],
        timeoutSeconds: 540,
        memory: '1GB'
    })
    .https.onCall(async (data, context) => {
        // 1. Verify authentication
        if (!context.auth) {
            throw new functions.https.HttpsError(
                'unauthenticated',
                'You must be signed in to generate images.'
            );
        }

        const userId = context.auth.uid;
        const { base64Image, filters } = data;

        // 2. Validate input
        if (!base64Image || !filters || !Array.isArray(filters)) {
            throw new functions.https.HttpsError(
                'invalid-argument',
                'Missing required fields: base64Image and filters'
            );
        }

        try {
            // 3. Check user credits
            const userRef = admin.firestore().collection('users').doc(userId);
            const userDoc = await userRef.get();

            if (!userDoc.exists) {
                throw new functions.https.HttpsError(
                    'not-found',
                    'User document not found'
                );
            }

            const userData = userDoc.data();
            if (userData.credits <= 0) {
                throw new functions.https.HttpsError(
                    'resource-exhausted',
                    'Insufficient credits. Please purchase more credits.'
                );
            }

            // 4. Call Gemini API
            const ai = getGeminiClient();

            // Build prompt from filters
            const changesList = filters.map(f => `- ${f.promptFragment}`).join('\n');
            const prompt = `
      You are an expert image editor specialized in urban renewal and civic planning visualization.
      
      Edit the attached image to show how it would look if it were perfectly maintained, clean, and upgraded. 
      Strictly maintain the original perspective, lighting direction, and main building structures. 
      Do not change the time of day. 
      
      CRITICAL: Treat any weathered, stained, peeling, or moldy wall surfaces as defects that must be repaired and painted.
      
      Apply the following specific modifications:
      ${changesList}
      
      Ensure the result looks photorealistic, natural, and inviting.
    `;

            const response = await ai.models.generateContent({
                model: 'gemini-3-pro-image-preview',
                contents: [
                    {
                        inlineData: {
                            mimeType: 'image/jpeg',
                            data: base64Image,
                        },
                    },
                    {
                        text: prompt,
                    },
                ],
            });

            // 5. Extract generated image
            const parts = response.candidates?.[0]?.content?.parts;
            if (!parts) {
                throw new functions.https.HttpsError(
                    'internal',
                    'No content generated by Gemini API'
                );
            }

            let generatedBase64 = '';
            for (const part of parts) {
                if (part.inlineData && part.inlineData.data) {
                    generatedBase64 = part.inlineData.data;
                    break;
                }
            }

            if (!generatedBase64) {
                throw new functions.https.HttpsError(
                    'internal',
                    'No image data found in Gemini response'
                );
            }

            // 6. Deduct 1 credit (using transaction for atomicity)
            await admin.firestore().runTransaction(async (transaction) => {
                const freshUserDoc = await transaction.get(userRef);
                const freshCredits = freshUserDoc.data().credits;

                if (freshCredits <= 0) {
                    throw new functions.https.HttpsError(
                        'resource-exhausted',
                        'Insufficient credits'
                    );
                }

                transaction.update(userRef, {
                    credits: admin.firestore.FieldValue.increment(-1),
                    lastUsedAt: admin.firestore.FieldValue.serverTimestamp(),
                });
            });

            // 7. Return generated image and updated credit count
            const updatedUserDoc = await userRef.get();
            const updatedCredits = updatedUserDoc.data().credits;

            return {
                success: true,
                generatedImage: generatedBase64,
                credits: updatedCredits,
            };

        } catch (error) {
            console.error('Error in generateImage:', error);

            if (error.code && error.code.startsWith('functions/')) {
                throw error; // Re-throw HttpsErrors
            }

            throw new functions.https.HttpsError(
                'internal',
                'Failed to generate image: ' + error.message
            );
        }
    });

/**
 * Cloud Function: addCredits
 * Called after successful payment to add credits to user account
 * In production, this would be called by a payment webhook (Razorpay/Stripe)
 */
exports.addCredits = functions.https.onCall(async (data, context) => {
    // Verify authentication
    if (!context.auth) {
        throw new functions.https.HttpsError(
            'unauthenticated',
            'You must be signed in'
        );
    }

    const userId = context.auth.uid;
    const { amount, paymentId } = data;

    // In production, verify payment with Razorpay/Stripe here
    // For now, this is a placeholder

    if (!amount || amount <= 0) {
        throw new functions.https.HttpsError(
            'invalid-argument',
            'Invalid credit amount'
        );
    }

    try {
        const userRef = admin.firestore().collection('users').doc(userId);

        await userRef.update({
            credits: admin.firestore.FieldValue.increment(amount),
            lastPurchaseAt: admin.firestore.FieldValue.serverTimestamp(),
        });

        const updatedDoc = await userRef.get();
        const updatedCredits = updatedDoc.data().credits;

        console.log(`Added ${amount} credits to user ${userId}`);

        return {
            success: true,
            credits: updatedCredits,
            message: `Successfully added ${amount} credits`,
        };
    } catch (error) {
        throw new functions.https.HttpsError(
            'internal',
            'Failed to add credits: ' + error.message
        );
    }
});

/**
 * Cloud Function: createRazorpayOrder
 * Creates a Razorpay order for credit purchase
 * SECURITY: Validates package server-side, never trusts client amounts
 */
exports.createRazorpayOrder = functions
    .runWith({
        secrets: ['RAZORPAY_KEY_ID', 'RAZORPAY_KEY_SECRET']
    })
    .https.onCall(async (data, context) => {
        // 1. Verify authentication
        if (!context.auth) {
            throw new functions.https.HttpsError(
                'unauthenticated',
                'You must be signed in to purchase credits'
            );
        }

        const userId = context.auth.uid;
        const { packageId } = data;

        // 2. Validate package ID exists (SERVER-SIDE LOOKUP - SECURITY CRITICAL)
        if (!packageId) {
            throw new functions.https.HttpsError(
                'invalid-argument',
                'Missing package selection'
            );
        }

        const pkg = PACKAGES[packageId];
        if (!pkg) {
            throw new functions.https.HttpsError(
                'invalid-argument',
                'Invalid package selected'
            );
        }

        // 3. Verify Razorpay keys are configured
        if (!process.env.RAZORPAY_KEY_ID || !process.env.RAZORPAY_KEY_SECRET) {
            console.error('Razorpay keys not configured');
            throw new functions.https.HttpsError(
                'internal',
                'Payment system not configured. Please try again later.'
            );
        }

        try {
            const { initializeRazorpay } = require('./razorpay-utils');

            // 4. Initialize Razorpay with environment variables (not hardcoded)
            const razorpay = initializeRazorpay(
                process.env.RAZORPAY_KEY_ID,
                process.env.RAZORPAY_KEY_SECRET
            );

            // 5. Create order with SERVER-SIDE values (never trust client)
            const amountInPaise = pkg.price * 100;
            const order = await razorpay.orders.create({
                amount: amountInPaise,
                currency: 'INR',
                receipt: `rcpt_${userId.slice(0, 8)}_${Date.now()}`,
                notes: {
                    userId,
                    packageId: pkg.id,
                    credits: pkg.credits.toString(),
                    expectedAmount: amountInPaise.toString()
                }
            });

            console.log(`Created Razorpay order: ${order.id} for user ${userId}, package: ${packageId}`);

            return {
                success: true,
                orderId: order.id,
                amount: order.amount,
                currency: order.currency,
                keyId: process.env.RAZORPAY_KEY_ID,
                packageName: pkg.name,
                credits: pkg.credits
            };

        } catch (error) {
            console.error('Error creating Razorpay order:', error);
            throw new functions.https.HttpsError(
                'internal',
                'Failed to create payment order. Please try again.'
            );
        }
    });

/**
 * Cloud Function: razorpayWebhook
 * Receives webhook notifications from Razorpay
 * Verifies signature and adds credits on successful payment
 * SECURITY: Uses rawBody for signature, validates amount, prevents double-credit
 */
exports.razorpayWebhook = functions
    .runWith({
        secrets: ['RAZORPAY_KEY_ID', 'RAZORPAY_KEY_SECRET', 'RAZORPAY_WEBHOOK_SECRET']
    })
    .https.onRequest(async (req, res) => {
        // 1. Verify webhook secret is configured
        if (!process.env.RAZORPAY_WEBHOOK_SECRET) {
            console.error('RAZORPAY_WEBHOOK_SECRET not configured');
            return res.status(500).send('Server configuration error');
        }

        try {
            // 2. Get signature and raw body
            const signature = req.headers['x-razorpay-signature'];
            const rawBody = req.rawBody;

            if (!signature || !rawBody) {
                console.error('Missing signature or body');
                return res.status(400).send('Invalid request');
            }

            // 3. Verify signature using RAW body (SECURITY CRITICAL)
            const expectedSignature = crypto
                .createHmac('sha256', process.env.RAZORPAY_WEBHOOK_SECRET)
                .update(rawBody)
                .digest('hex');

            if (expectedSignature !== signature) {
                console.error('Invalid webhook signature');
                return res.status(400).send('Invalid signature');
            }

            // 4. Parse body after verification
            const payload = JSON.parse(rawBody.toString());
            const event = payload.event;

            console.log(`Received Razorpay webhook: ${event}`);

            // 5. Handle payment.captured event
            if (event === 'payment.captured') {
                await handlePaymentCaptured(payload, res);
                return;
            }

            // 6. Handle payment.failed event
            if (event === 'payment.failed') {
                await handlePaymentFailed(payload);
            }

            res.status(200).send('OK');

        } catch (error) {
            console.error('Error processing webhook:', error);

            // Log for manual review
            try {
                await admin.firestore().collection('failed_webhooks').add({
                    error: error.message,
                    timestamp: admin.firestore.FieldValue.serverTimestamp()
                });
            } catch (logError) {
                console.error('Failed to log webhook error:', logError);
            }

            res.status(500).send('Internal error');
        }
    });

/**
 * Handle successful payment capture
 * SECURITY: Validates amount matches expected, prevents double-credit
 */
async function handlePaymentCaptured(payload, res) {
    const { initializeRazorpay } = require('./razorpay-utils');

    const paymentEntity = payload.payload.payment.entity;
    const orderId = paymentEntity.order_id;
    const paymentId = paymentEntity.id;
    const paidAmount = paymentEntity.amount;

    // 1. Verify Razorpay keys
    if (!process.env.RAZORPAY_KEY_ID || !process.env.RAZORPAY_KEY_SECRET) {
        throw new Error('Razorpay keys not configured');
    }

    // 2. Fetch order to get notes
    const razorpay = initializeRazorpay(
        process.env.RAZORPAY_KEY_ID,
        process.env.RAZORPAY_KEY_SECRET
    );

    const order = await razorpay.orders.fetch(orderId);
    const { userId, packageId, credits, expectedAmount } = order.notes;

    // 3. Validate required fields
    if (!userId || !packageId || !credits) {
        console.error(`Missing order notes: userId=${userId}, packageId=${packageId}, credits=${credits}`);
        return res.status(400).send('Invalid order data');
    }

    // 4. SECURITY: Validate amount matches expected
    if (expectedAmount && paidAmount.toString() !== expectedAmount) {
        console.error(`Amount mismatch: paid=${paidAmount}, expected=${expectedAmount}`);
        return res.status(400).send('Amount mismatch');
    }

    // 5. Check for duplicate processing (prevent double-credit)
    const paymentsRef = admin.firestore().collection('payments');
    const existingPayment = await paymentsRef.doc(paymentId).get();

    if (existingPayment.exists) {
        console.log(`Payment ${paymentId} already processed, skipping`);
        return res.status(200).send('OK');
    }

    // 6. Add credits using transaction
    const userRef = admin.firestore().collection('users').doc(userId);

    await admin.firestore().runTransaction(async (transaction) => {
        const userDoc = await transaction.get(userRef);

        if (!userDoc.exists) {
            throw new Error(`User ${userId} not found`);
        }

        // Update user credits
        transaction.update(userRef, {
            credits: admin.firestore.FieldValue.increment(parseInt(credits)),
            lastPurchaseAt: admin.firestore.FieldValue.serverTimestamp(),
        });

        // Record payment
        transaction.set(paymentsRef.doc(paymentId), {
            userId,
            orderId,
            paymentId,
            packageId,
            amount: paidAmount / 100,
            credits: parseInt(credits),
            status: 'captured',
            createdAt: admin.firestore.FieldValue.serverTimestamp(),
        });
    });

    console.log(`Added ${credits} credits to user ${userId} for payment ${paymentId}`);
    res.status(200).send('OK');
}

/**
 * Handle failed payment for analytics
 */
async function handlePaymentFailed(payload) {
    const paymentEntity = payload.payload.payment.entity;
    const orderId = paymentEntity.order_id;
    const paymentId = paymentEntity.id;
    const errorCode = paymentEntity.error_code;
    const errorDescription = paymentEntity.error_description;

    console.log(`Payment failed: ${paymentId}, error: ${errorCode} - ${errorDescription}`);

    // Record failed payment for analytics
    await admin.firestore().collection('failed_payments').add({
        orderId,
        paymentId,
        errorCode,
        errorDescription,
        timestamp: admin.firestore.FieldValue.serverTimestamp(),
    });
}

/**
 * Cloud Function: verifyPayment
 * Client-side backup verification after Razorpay checkout success
 * Called to confirm payment was processed (webhook may be delayed)
 */
exports.verifyPayment = functions
    .runWith({
        secrets: ['RAZORPAY_KEY_SECRET']
    })
    .https.onCall(async (data, context) => {
        // 1. Verify authentication
        if (!context.auth) {
            throw new functions.https.HttpsError(
                'unauthenticated',
                'You must be signed in'
            );
        }

        const { orderId, paymentId, signature } = data;
        const userId = context.auth.uid;

        // 2. Validate input
        if (!orderId || !paymentId || !signature) {
            throw new functions.https.HttpsError(
                'invalid-argument',
                'Missing payment verification data'
            );
        }

        // 3. Verify Razorpay signature
        const { verifyPaymentSignature } = require('./razorpay-utils');
        const isValid = verifyPaymentSignature(
            orderId,
            paymentId,
            signature,
            process.env.RAZORPAY_KEY_SECRET
        );

        if (!isValid) {
            console.error(`Invalid payment signature for ${paymentId}`);
            throw new functions.https.HttpsError(
                'invalid-argument',
                'Invalid payment signature'
            );
        }

        // 4. Check if payment was processed by webhook
        const paymentDoc = await admin.firestore()
            .collection('payments')
            .doc(paymentId)
            .get();

        if (paymentDoc.exists) {
            const payment = paymentDoc.data();
            
            // Security: Verify payment belongs to this user
            if (payment.userId !== userId) {
                throw new functions.https.HttpsError(
                    'permission-denied',
                    'Payment belongs to another user'
                );
            }

            return {
                success: true,
                processed: true,
                credits: payment.credits,
                message: 'Payment verified and credits added'
            };
        }

        // 5. Payment not yet processed (webhook may be delayed)
        // Client should poll or wait for Firestore listener update
        return {
            success: true,
            processed: false,
            message: 'Payment received, credits will be added shortly'
        };
    });
